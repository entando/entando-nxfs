/*
 * NxFs
 *
 * Simple file access APIs for the Entando Nx subsystem
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nxsiteman

import (
	"context"
	"errors"
	"fmt"
	pkgErr "github.com/pkg/errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
)

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() DefaultApiServicer {
	return &DefaultApiService{}
}

// ApiNxfsBrowseEncodedPathGet - Gets the list of objects in a directory
func (s *DefaultApiService) ApiNxfsBrowseEncodedPathGet(ctx context.Context, encodedPath string, maxdepth int32) (ImplResponse, error) {

	pathToBrowse, fileInfoToBrowse, errorReponse := composeFullPathOrErrorResponse(encodedPath)
	if nil != errorReponse {
		return *errorReponse, nil
	}

	// recursive function
	dirObjectArray, err := browseFileTree(pathToBrowse, fileInfoToBrowse, 0, maxdepth, []DirectoryObject{})
	if nil != err {
		return *ErrorResponse(http.StatusInternalServerError, "dir_listing_err", err.Error()), nil
	}

	return Response(http.StatusOK, FlatDirectoryTree{dirObjectArray}), nil
}

// ApiNxfsObjectsEncodedPathDelete - Deletes an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathDelete(ctx context.Context, encodedPath string) (ImplResponse, error) {
	// TODO - update ApiNxfsObjectsEncodedPathDelete with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(204, {}) or use other options such as http.Ok ...
	//return Response(204, nil),nil

	//TODO: Uncomment the next line to return response Response(0, Error{}) or use other options such as http.Ok ...
	//return Response(0, Error{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("ApiNxfsObjectsEncodedPathDelete method not implemented")
}

// ApiNxfsObjectsEncodedPathGet - Gets an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathGet(ctx context.Context, encodedPath string) (ImplResponse, error) {

	pathToBrowse, requestedFile, errorReponse := composeFullPathOrErrorResponse(encodedPath)
	if nil != errorReponse {
		return *errorReponse, nil
	}

	// if dir return error
	if requestedFile.IsDir() {
		return *ErrorResponse(http.StatusBadRequest, "dir_requested", "The received encoded path "+
			"corresponds to a directory. This endpoint returns files content, to browse a directory please use the browse one"), nil
	}

	// return file content
	fileContent, err := ioutil.ReadFile(path.Join(pathToBrowse, requestedFile.Name()))
	if err != nil {
		return *ErrorResponse(http.StatusBadRequest, "err_reading_content",
			fmt.Sprintf("An error occurred during the reading of the file content: %q", err.Error())), nil
	}

	// Convert []byte to string and print to screen
	fileContentString := string(fileContent)

	return Response(http.StatusOK, toFileObject(pathToBrowse, requestedFile, fileContentString)), nil
}

// ApiNxfsObjectsEncodedPathPublishPost - Publishes an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathPublishPost(ctx context.Context, encodedPath string) (ImplResponse, error) {
	// TODO - update ApiNxfsObjectsEncodedPathPublishPost with the required logic for this service method.
	// Add api_default_service.go to the .openapi-generator-ignore to avoid overwriting this service implementation when updating open api generation.

	//TODO: Uncomment the next line to return response Response(200, DirectoryObject{}) or use other options such as http.Ok ...
	//return Response(200, DirectoryObject{}), nil

	//TODO: Uncomment the next line to return response Response(0, Error{}) or use other options such as http.Ok ...
	//return Response(0, Error{}), nil

	return Response(http.StatusNotImplemented, nil), errors.New("ApiNxfsObjectsEncodedPathPublishPost method not implemented")
}

// ApiNxfsObjectsEncodedPathPut - Creates or updates an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathPut(ctx context.Context, encodedPath string, fileObject FileObject) (ImplResponse, error) {

	// dir can't have content
	if fileObject.Type == D && "" != fileObject.Content {
		return *ErrorResponse(http.StatusBadRequest, "full_content_for_dir", "A creation dir request can't contain a file content value"), nil
	} else if fileObject.Type == F && "" == fileObject.Content {
		// file must have content
		return *ErrorResponse(http.StatusBadRequest, "empty_content", "A file with empty content can't be saved"), nil
	}

	decodedPath, errResponse := decodePath(encodedPath)
	if nil != errResponse {
		return *errResponse, nil
	}

	fullPathToSave := filepath.Join(GetBrowsableFsRootPath(), decodedPath)

	var errResp *ImplResponse
	if fileObject.Type == D {
		errResp = createDirectory(fullPathToSave)
	} else {
		errResp = createFile(fullPathToSave, fileObject)
	}

	if nil != errResp {
		return *errResp, nil
	} else {
		return Response(http.StatusCreated, toDirectoryObjectFromFilePath(fullPathToSave)), nil
	}
}

// browseFileTree - traverse recursively the path represented by fileInfo
func browseFileTree(path string, fileInfo os.FileInfo, currDepth int32, maxDepth int32, directoryObjects []DirectoryObject) ([]DirectoryObject, error) {

	// if depth reached return
	if currDepth > maxDepth && maxDepth != 0 {
		return directoryObjects, nil
	}

	// if the current one is a file add it to the result list and return
	if !fileInfo.IsDir() {
		directoryObjects = append(directoryObjects, toDirectoryObject(path, fileInfo))
		return directoryObjects, nil
	}

	// otherwise proceed with the tree inspection
	dirAbsPath := filepath.Join(path, fileInfo.Name())

	// read dir
	readFilesInfo, err := ioutil.ReadDir(dirAbsPath)
	if nil != err {
		return directoryObjects, pkgErr.Wrap(err, fmt.Sprintf("can't read directory %s", dirAbsPath))
	}

	// call recursively
	for _, file := range readFilesInfo {
		directoryObjects, err = browseFileTree(dirAbsPath, file, currDepth+1, maxDepth, directoryObjects)
		if nil != err {
			return directoryObjects, err
		}
	}

	return directoryObjects, nil
}

// composeFullPathOrErrorResponse - receives a URL encoded path, decodes it and return the corresponding full path (without filename), the fileInfo of the requested file/folder and a possible REST response containing an error
func composeFullPathOrErrorResponse(encodedPath string) (fullPath string, fileInfoToBrowse os.FileInfo, errorResponse *ImplResponse) {

	// define paths
	decodedPath, errResponse := decodePath(encodedPath)
	if nil != errResponse {
		return "", nil, errResponse
	}

	fullPathToBrowse := filepath.Join(GetBrowsableFsRootPath(), decodedPath)

	// does path exist?
	var err error
	if fileInfoToBrowse, err = os.Stat(fullPathToBrowse); os.IsNotExist(err) {
		return "", nil, ErrorResponse(http.StatusNotFound, "path_not_found", err.Error())
	}

	// extract pathToBrowse path
	fullPath = path.Dir(fullPathToBrowse)

	return fullPath, fileInfoToBrowse, nil
}

// decodePath - receives an url encoded path, decodes and returns it. if a decode error occurs, it will return an error ImplResponse
func decodePath(encodedPath string) (decodedPath string, errorResponse *ImplResponse) {

	var err error
	decodedPath, err = url.PathUnescape(encodedPath)
	if nil != err {
		return "", ErrorResponse(http.StatusInternalServerError, "error_decoding_path", err.Error())
	}

	return decodedPath, nil
}

// createDirectory - create a directory in the received path. return an error ImplResponse if an error occurs, nil otherwise
func createDirectory(dirPath string) (errorResp *ImplResponse) {

	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		err := os.Mkdir(dirPath, 0755)
		if nil != err {
			errorResp = ErrorResponse(http.StatusBadRequest, "dir_write_error", err.Error())
		}
	}

	return errorResp
}

// createFile - create a file in the received path containing the received content return an error ImplResponse if an error occurs, nil otherwise
func createFile(path string, fileObject FileObject) (errorResp *ImplResponse) {

	data := []byte(fileObject.Content)
	err := ioutil.WriteFile(path, data, 0644)
	if nil != err {
		errorResp = ErrorResponse(http.StatusBadRequest, "write_error", err.Error())
	}

	return errorResp
}
