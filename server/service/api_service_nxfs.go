/*
 * NxFs
 *
 * Simple file access APIs for the Entando Nx subsystem
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package service

import (
	"context"
	"fmt"
	"github.com/entando/entando-nxfs/server/controller"
	"github.com/entando/entando-nxfs/server/helper"
	"github.com/entando/entando-nxfs/server/model"
	"github.com/entando/entando-nxfs/server/net"
	"github.com/entando/entando-nxfs/server/nxfsfiles"
	"github.com/entando/entando-nxfs/server/nxfspages"
	"io/ioutil"
	"net/http"
	"os"
	"path"
	"path/filepath"
)

// DefaultApiService is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
// Include any external packages or services that will be required by this service.
type DefaultApiService struct {
	modelAssembler helper.ModelAssembler
	fileManager    nxfsfiles.FileManager
	pageManager    nxfspages.PageManager
}

// NewDefaultApiService creates a default api service
func NewDefaultApiService() controller.DefaultApiServicer {

	modelAssembler := helper.NewModelAssembler(helper.GetBrowsableFsRootPath)
	fileManager := nxfsfiles.NewFileManager(modelAssembler)

	return &DefaultApiService{
		modelAssembler: modelAssembler,
		fileManager:    fileManager,
		pageManager:    nxfspages.NewPageManager(fileManager),
	}
}

// ApiNxfsBrowseEncodedPathGet - Gets the list of objects in a directory
func (s *DefaultApiService) ApiNxfsBrowseEncodedPathGet(ctx context.Context, encodedPath string, maxdepth int32, publishedPages bool) (net.NxfsResponse, error) {

	return composeFullPathOrErrorAndExecuteApiNxfsFunction(ctx, s.fileManager, encodedPath, func(pathToBrowse string, fileInfoToBrowse os.FileInfo) (net.NxfsResponse, error) {
		// recursive function
		dirObjectArray, err := s.fileManager.BrowseFileTree(pathToBrowse, fileInfoToBrowse, 0, maxdepth, []model.DirectoryObject{}, publishedPages)
		if err != nil {
			return *helper.ErrorResponse(http.StatusInternalServerError, "dir_listing_err", err.Error()), nil
		}

		return helper.SuccessResponse(http.StatusOK, model.FlatDirectoryTree{List: dirObjectArray}), nil
	})
}

// ApiNxfsObjectsEncodedPathDelete - Deletes an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathDelete(ctx context.Context, encodedPath string) (net.NxfsResponse, error) {

	pathToDelete, fileToDelete, errorResponse := s.fileManager.ComposeFullPathOrErrorResponse(encodedPath)
	if errorResponse != nil {
		if errorResponse.Code == http.StatusNotFound {
			return helper.SuccessResponse(http.StatusNoContent, nil), nil
		} else {
			return *errorResponse, nil
		}
	}
	absPathFile := path.Join(pathToDelete, fileToDelete.Name())

	if s.fileManager.IsDirWithChildren(absPathFile, fileToDelete) {
		return *helper.ErrorResponse(http.StatusUnprocessableEntity, "dir_not_empty", "The folder to delete is not empty"), nil
	}

	if errorResponse = s.fileManager.DeleteFile(absPathFile); errorResponse != nil {
		return *errorResponse, nil
	}

	return helper.SuccessResponse(http.StatusNoContent, nil), nil
}

// ApiNxfsObjectsEncodedPathGet - Gets an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathGet(ctx context.Context, encodedPath string) (net.NxfsResponse, error) {

	return composeFullPathOrErrorAndExecuteApiNxfsFunction(ctx, s.fileManager, encodedPath, func(pathToBrowse string, requestedFile os.FileInfo) (net.NxfsResponse, error) {
		// if dir return error
		if requestedFile.IsDir() {
			return *helper.ErrorResponse(http.StatusBadRequest, "dir_requested", "The received encoded path "+
				"corresponds to a directory. This endpoint returns files content, to browse a directory please use the browse one"), nil
		}

		// return file content
		fileContent, err := ioutil.ReadFile(path.Join(pathToBrowse, requestedFile.Name()))
		if err != nil {
			return *helper.ErrorResponse(http.StatusBadRequest, "err_reading_content",
				fmt.Sprintf("An error occurred during the reading of the file content: %q", err.Error())), nil
		}

		// Convert []byte to string and print to screen
		fileContentString := string(fileContent)

		return helper.SuccessResponse(http.StatusOK, s.modelAssembler.ToFileObject(pathToBrowse, requestedFile, fileContentString)), nil
	})
}

// ApiNxfsObjectsEncodedPathPut - Creates or updates an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathPut(ctx context.Context, encodedPath string, fileObject model.FileObject) (net.NxfsResponse, error) {

	// dir can't have content
	if fileObject.Type == model.D && "" != fileObject.Content {
		return *helper.ErrorResponse(http.StatusBadRequest, "full_content_for_dir", "A creation dir request can't contain a file content value"), nil
	} else if fileObject.Type == model.F && "" == fileObject.Content {
		// file must have content
		return *helper.ErrorResponse(http.StatusBadRequest, "empty_content", "A file with empty content can't be saved"), nil
	}

	decodedPath, decodeErrResp := s.fileManager.DecodePath(encodedPath)
	if decodeErrResp != nil {
		return *decodeErrResp, nil
	}

	fullPathToSave := filepath.Join(helper.GetBrowsableFsRootPath(), decodedPath)

	var creationErrResp *net.NxfsResponse
	if fileObject.Type == model.D {
		creationErrResp = s.fileManager.CreateDirectory(fullPathToSave)
	} else {
		creationErrResp = s.fileManager.CreateFile(fullPathToSave, fileObject)
	}

	if creationErrResp != nil {
		return *creationErrResp, nil
	} else if fileObject.Type == model.D {
		return helper.SuccessResponse(http.StatusCreated, s.modelAssembler.ToDirectoryObjectFromFilePath(fullPathToSave)), nil
	} else {
		return helper.SuccessResponse(http.StatusCreated, s.modelAssembler.ToFileObjectFromFilePath(fullPathToSave, fileObject.Content)), nil
	}
}

// ApiNxfsObjectsEncodedPathPublishPost - Publishes an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathPublishPost(ctx context.Context, encodedPath string) (net.NxfsResponse, error) {

	if errorResponse := s.pageManager.PublishPage(encodedPath); errorResponse != nil {
		return *errorResponse, nil
	} else {
		return helper.SuccessResponse(http.StatusOK, nil), nil
	}
}

// ApiNxfsObjectsEncodedPathUnpublishPost - Publishes an object
func (s *DefaultApiService) ApiNxfsObjectsEncodedPathUnpublishPost(ctx context.Context, encodedPath string) (net.NxfsResponse, error) {

	if errorResponse := s.pageManager.UnpublishPage(encodedPath); errorResponse != nil {
		return *errorResponse, nil
	} else {
		return helper.SuccessResponse(http.StatusOK, nil), nil
	}
}

// DecodedPathAndExecuteApiNxfsFunction - decode the received encodedPath and execute the fnWithDecodedPath function passing it the result of the decoding
func composeFullPathOrErrorAndExecuteApiNxfsFunction(ctx context.Context, fileManager nxfsfiles.FileManager, encodedPath string, fnWithDecodedPath apiNxfsFunctionWithComposeFullPathOrError) (net.NxfsResponse, error) {

	pathToBrowse, fileInfoToBrowse, errorResponse := fileManager.ComposeFullPathOrErrorResponse(encodedPath)
	if errorResponse != nil {
		return *errorResponse, nil
	}

	return fnWithDecodedPath(pathToBrowse, fileInfoToBrowse)
}

// apiNxfsFunctionWithcomposeFullPathOrError - a function that receives the result of a path decoding
type apiNxfsFunctionWithComposeFullPathOrError func(pathToBrowse string, fileInfoToBrowse os.FileInfo) (net.NxfsResponse, error)
